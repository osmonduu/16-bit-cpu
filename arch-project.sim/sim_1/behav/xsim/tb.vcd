$date
   Mon Apr 14 13:11:37 2025
$end

$version
  2024.2.0
  $dumpfile ("tb.vcd") 
$end

$timescale
  1ps
$end

$scope module full_tb $end
$var reg 16 ! reg_write [15:0] $end
$var reg 16 " mem_write [15:0] $end
$var reg 16 # reg_result [15:0] $end
$var reg 16 $ mem_result [15:0] $end
$var reg 32 % idx [31:0] $end
$var reg 1 & clock $end
$var reg 32 ' reg_operation_type [31:0] $end
$var reg 32 ( daddr [31:0] $end
$var reg 32 ) iaddr [31:0] $end
$var reg 32 * current_address [31:0] $end
$var reg 32 + next_address [31:0] $end
$var reg 16 , fetched_instruction [15:0] $end
$var reg 16 - instruction [15:0] $end
$var reg 1 . branch_flag $end
$var reg 1 / branch_select_flag $end
$var reg 1 0 alu_zero_flag $end
$var reg 1 1 jump_flag $end
$var reg 4 2 opcode [3:0] $end
$var reg 1 3 control_reset $end
$var reg 1 4 mem_to_reg_flag $end
$var reg 2 5 alu_op [1:0] $end
$var reg 1 6 mem_read_flag $end
$var reg 1 7 mem_write_flag $end
$var reg 1 8 aluSrc_flag $end
$var reg 1 9 reg_write_flag $end
$var reg 1 : reg_read_flag $end
$var reg 4 ; func [3:0] $end
$var reg 3 < alu_control_out [2:0] $end
$var reg 16 = reg1_contents [15:0] $end
$var reg 16 > reg2_contents [15:0] $end
$var reg 16 ? alu_result [15:0] $end
$var reg 16 @ data_memory_output [15:0] $end
$var reg 16 A memToReg_mux_output [15:0] $end
$var wire 1 B mem_to_ $end
$scope module pc $end
$var wire 1 C clock $end
$var reg 32 * pc_current [31:0] $end
$var wire 1 D flag_branch $end
$var wire 1 E flag_branch_select $end
$var wire 1 F aluZero $end
$var wire 1 G flag_jump $end
$var wire 16 H fullInstr [15:0] $end
$var reg 32 + pc_next [31:0] $end
$var reg 32 I nextAddr [31:0] $end
$var reg 32 J branchAddr [31:0] $end
$var reg 32 K signExtImm [31:0] $end
$var reg 1 L beq_logic $end
$var reg 1 M bne_logic $end
$var reg 1 N branchMux $end
$var reg 32 O pcSrc [31:0] $end
$var reg 32 P jumpAddr [31:0] $end
$upscope $end
$scope module ra $end
$var reg 16 ! incomingData [15:0] $end
$var reg 32 % index [31:0] $end
$var reg 1 & clock $end
$var reg 1 9 write_flag $end
$var reg 16 # outgoingData [15:0] $end
$upscope $end
$scope module imem $end
$var reg 32 ) addr [31:0] $end
$var reg 16 , outWord [15:0] $end
$var reg 8 Q temp1 [7:0] $end
$var reg 8 R temp2 [7:0] $end
$upscope $end
$scope module dmem $end
$var reg 16 " inWord [15:0] $end
$var reg 1 & clock $end
$var reg 32 ( addr [31:0] $end
$var wire 1 S read_flag $end
$var wire 1 T write_flag $end
$var reg 16 $ outWord [15:0] $end
$scope begin Block38_6 $end
$var reg 32 U wmemtrnsf_fd [31:0] $end
$scope begin Block38_7 $end
$var reg 32 V i1 [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module con $end
$var wire 4 W opcode [3:0] $end
$var wire 1 X control_reset $end
$var reg 1 1 jump $end
$var reg 1 . branch $end
$var reg 1 / branch_select $end
$var reg 1 6 mem_read $end
$var reg 1 Y mem_to_reg $end
$var reg 2 5 alu_op [1:0] $end
$var reg 1 7 mem_write $end
$var reg 1 8 aluSrc $end
$var reg 1 9 reg_write $end
$upscope $end
$scope module alu_con $end
$var wire 2 Z alu_op [1:0] $end
$var wire 4 [ func [3:0] $end
$var reg 3 < alu_control_var [2:0] $end
$var reg 6 \ alu_control_inp [5:0] $end
$upscope $end
$scope module alu $end
$var wire 16 ] input1 [15:0] $end
$var wire 16 ^ input2 [15:0] $end
$var wire 16 _ fullInstr [15:0] $end
$var wire 1 ` flag_aluSrc $end
$var wire 3 a alu_control_out [2:0] $end
$var reg 16 ? result [15:0] $end
$var reg 1 0 zero_flag $end
$var reg 16 b adderFirstOperand [15:0] $end
$var reg 16 c signExtImm [15:0] $end
$upscope $end
$upscope $end
$enddefinitions $end

#0
$dumpvars
b0 !
b0 "
b0 #
b0 $
b11 %
0&
b1 '
b1000000 (
b0 )
b0 *
b0 +
b100100000 ,
b0 -
0.
0/
x0
01
bx 2
03
x4
b0 5
06
07
08
09
0:
bx ;
b10 <
bx =
bx >
bx ?
b0 @
b0 A
0B
0C
0D
0E
xF
0G
b0 H
b0 I
b0 J
b0 K
xL
xM
xN
b0 O
b0 P
b1 Q
b100000 R
0S
0T
b0 U
b0 V
bx W
0X
0Y
b0 Z
bx [
b0xxxx \
bx ]
bx ^
b0 _
0`
b10 a
bx b
b0 c
$end

#1000
b0 2
b10 5
19
b0 <
b0 W
b10 Z
b10xxxx \
b0 a

#2000
b0 ;
b10 <
b0 [
b100000 \
b10 a

#3000
b0 %
b0 '

#4000
bx !
b1 '
10
b0 =
b0 >
b0 ?
bx A
1F
b0 ]
b0 ^
b0 b

#5000
b10000 %

#6000
1&
b10 +
1C
b10 I
b10 J
0L
0M
0N
b10 O

#7000
bx #
0&
0C

#8000
b10 !

#9000
b0 '

#10000
b0 *

#14000
b0 %

#15000
b0 !
b1 '
x0
bx =
bx >
bx ?
b0 A
xF
bx ]
bx ^
bx b

#16000
b10000 %

#17000
1&
1C

#18000
b0 #
0&
0C

#19000
b10 !

#20000
b0 '

#25000
b0 %

#26000
bx !
b1 '
10
b0 =
b0 >
b0 ?
bx A
1F
b0 ]
b0 ^
b0 b

#27000
b10000 %

#28000
1&
1C

#29000
bx #
0&
0C

#30000
b10 !

#31000
b0 '

#32000
b0 *

#36000
b0 %

#37000
b0 !
b1 '
x0
bx =
bx >
bx ?
b0 A
xF
bx ]
bx ^
bx b

#38000
b10000 %

#39000
1&
1C

#40000
b0 #
0&
0C

#41000
b10 !

#42000
b0 '

#47000
b0 %

#48000
bx !
b1 '
10
b0 =
b0 >
b0 ?
bx A
1F
b0 ]
b0 ^
b0 b

#49000
b10000 %

#50000
1&
1C

#51000
bx #
0&
0C

#52000
b10 !

#53000
b0 '

#54000
b0 *

#58000
b0 %

#59000
b0 !
b1 '
x0
bx =
bx >
bx ?
b0 A
xF
bx ]
bx ^
bx b

#60000
b10000 %

#61000
1&
1C

#62000
b0 #
0&
0C

#63000
b10 !

#64000
b0 '

#69000
b0 %

#70000
bx !
b1 '
10
b0 =
b0 >
b0 ?
bx A
1F
b0 ]
b0 ^
b0 b

#71000
b10000 %

#72000
1&
1C

#73000
bx #
0&
0C

#74000
b10 !

#75000
b0 '

#76000
b0 *

#80000
b0 %

#81000
b0 !
b1 '
x0
bx =
bx >
bx ?
b0 A
xF
bx ]
bx ^
bx b

#82000
b10000 %

#83000
1&
1C

#84000
b0 #
0&
0C

#85000
b10 !

#86000
b0 '

#91000
b0 %

#92000
bx !
b1 '
10
b0 =
b0 >
b0 ?
bx A
1F
b0 ]
b0 ^
b0 b

#93000
b10000 %

#94000
1&
1C

#95000
bx #
0&
0C

#96000
b10 !

#97000
b0 '

#98000
b0 *

#102000
b0 %

#103000
b0 !
b1 '
x0
bx =
bx >
bx ?
b0 A
xF
bx ]
bx ^
bx b

#104000
b10000 %

#105000
1&
1C

#106000
b0 #
0&
0C

#107000
b10 !

#108000
b0 '

#113000
b0 %

#114000
bx !
b1 '
10
b0 =
b0 >
b0 ?
bx A
1F
b0 ]
b0 ^
b0 b

#115000
b10000 %

#116000
1&
1C

#117000
bx #
0&
0C

#118000
b10 !
