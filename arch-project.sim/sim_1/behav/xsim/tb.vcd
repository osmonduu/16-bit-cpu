$date
   Sat Apr 12 17:09:14 2025
$end

$version
  2024.2.0
  $dumpfile ("tb.vcd") 
$end

$timescale
  1ps
$end

$scope module full_tb $end
$var reg 16 ! reg_write [15:0] $end
$var reg 16 " mem_write [15:0] $end
$var reg 16 # reg_result [15:0] $end
$var reg 16 $ mem_result [15:0] $end
$var reg 32 % idx [31:0] $end
$var reg 1 & clock $end
$var reg 32 ' reg_operation_type [31:0] $end
$var reg 32 ( daddr [31:0] $end
$var reg 32 ) iaddr [31:0] $end
$var reg 32 * current_address [31:0] $end
$var reg 32 + next_address [31:0] $end
$var wire 16 , instruction [15:0] $end
$var reg 1 - branch_flag $end
$var reg 1 . branch_select_flag $end
$var reg 1 / alu_zero_flag $end
$var reg 1 0 jump_flag $end
$var reg 4 1 opcode [3:0] $end
$var reg 1 2 control_reset $end
$var reg 1 3 mem_read_flag $end
$var reg 1 4 mem_to_reg_flag $end
$var reg 2 5 alu_op [1:0] $end
$var reg 1 6 mem_write_flag $end
$var reg 1 7 aluSrc_flag $end
$var reg 1 8 reg_write_flag $end
$var reg 4 9 func [3:0] $end
$var reg 3 : alu_control_out [2:0] $end
$var reg 16 ; reg1_contents [15:0] $end
$var reg 16 < reg2_contents [15:0] $end
$var reg 16 = alu_result [15:0] $end
$var reg 16 > data_memory_output [15:0] $end
$var reg 16 ? memToReg_mux_output [15:0] $end
$var wire 1 @ mem_to_ $end
$scope module con $end
$var wire 4 A opcode [3:0] $end
$var wire 1 B control_reset $end
$var reg 1 0 jump $end
$var reg 1 - branch $end
$var reg 1 . branch_select $end
$var reg 1 3 mem_read $end
$var reg 1 C mem_to_reg $end
$var reg 2 5 alu_op [1:0] $end
$var reg 1 6 mem_write $end
$var reg 1 7 aluSrc $end
$var reg 1 8 reg_write $end
$upscope $end
$scope module alu_con $end
$var wire 2 D alu_op [1:0] $end
$var wire 4 E func [3:0] $end
$var reg 3 : alu_control_var [2:0] $end
$var reg 6 F alu_control_inp [5:0] $end
$upscope $end
$scope module alu $end
$var wire 16 G input1 [15:0] $end
$var wire 16 H input2 [15:0] $end
$var wire 16 , fullInstr [15:0] $end
$var wire 1 I flag_aluSrc $end
$var wire 3 J alu_control_out [2:0] $end
$var reg 16 = result [15:0] $end
$var reg 1 / zero_flag $end
$var reg 16 K adderFirstOperand [15:0] $end
$var reg 16 L signExtImm [15:0] $end
$upscope $end
$scope module pc $end
$var wire 1 M clock $end
$var reg 32 * pc_current [31:0] $end
$var wire 1 N flag_branch $end
$var wire 1 O flag_branch_select $end
$var wire 1 P aluZero $end
$var wire 1 Q flag_jump $end
$var wire 16 , fullInstr [15:0] $end
$var reg 32 + pc_next [31:0] $end
$var reg 32 R nextAddr [31:0] $end
$var reg 32 S branchAddr [31:0] $end
$var reg 32 T signExtImm [31:0] $end
$var reg 1 U beq_logic $end
$var reg 1 V bne_logic $end
$var reg 1 W branchMux $end
$var reg 32 X pcSrc [31:0] $end
$var reg 32 Y jumpAddr [31:0] $end
$upscope $end
$scope module ra $end
$var reg 16 ! incomingData [15:0] $end
$var reg 32 % index [31:0] $end
$var reg 32 ' accessType [31:0] $end
$var wire 1 Z clk $end
$var reg 16 # outgoingData [15:0] $end
$upscope $end
$scope module imem $end
$var reg 32 ) addr [31:0] $end
$var wire 16 , outWord [15:0] $end
$upscope $end
$scope module dmem $end
$var reg 16 " inWord [15:0] $end
$var reg 32 ( addr [31:0] $end
$var wire 1 [ read_flag $end
$var wire 1 \ write_flag $end
$var reg 16 $ outWord [15:0] $end
$scope begin Block32_6 $end
$var reg 32 ] wmemtrnsf_fd [31:0] $end
$scope begin Block32_7 $end
$var reg 32 ^ i1 [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end

#0
$dumpvars
b0 !
b0 "
b0 #
b0 $
b10000 %
0&
b1 '
b1000000 (
b0 )
b0 *
b0 +
b100100000 ,
0-
0.
1/
00
b0 1
02
03
04
b10 5
06
07
18
b0 9
b10 :
b0 ;
b0 <
b0 =
b0 >
b0 ?
0@
b0 A
0B
0C
b10 D
b0 E
b100000 F
b0 G
b0 H
0I
b10 J
b0 K
b0 L
0M
0N
0O
1P
0Q
b0 R
b0 S
b0 T
xU
xV
xW
b0 X
b0 Y
0Z
0[
0\
b0 ]
b0 ^
$end

#1000
1&
b10 +
1M
b10 R
b10 S
0U
0V
0W
b10 X
b1001000000 Y
1Z
