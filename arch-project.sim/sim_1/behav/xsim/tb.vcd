$date
   Mon Apr 14 16:01:25 2025
$end

$version
  2024.2.0
  $dumpfile ("tb.vcd") 
$end

$timescale
  1ps
$end

$scope module full_tb $end
$var reg 16 ! reg_write [15:0] $end
$var reg 16 " mem_write [15:0] $end
$var reg 16 # reg_result [15:0] $end
$var reg 16 $ dmem_result [15:0] $end
$var reg 32 % idx [31:0] $end
$var reg 1 & clock $end
$var reg 32 ' reg_operation_type [31:0] $end
$var reg 32 ( daddr [31:0] $end
$var reg 32 ) iaddr [31:0] $end
$var reg 32 * current_address [31:0] $end
$var reg 32 + next_address [31:0] $end
$var reg 16 , instruction [15:0] $end
$var reg 1 - branch_flag $end
$var reg 1 . branch_select_flag $end
$var reg 1 / alu_zero_flag $end
$var reg 1 0 jump_flag $end
$var reg 4 1 opcode [3:0] $end
$var reg 1 2 control_reset $end
$var reg 1 3 mem_to_reg_flag $end
$var reg 2 4 alu_op [1:0] $end
$var reg 1 5 mem_read_flag $end
$var reg 1 6 mem_write_flag $end
$var reg 1 7 aluSrc_flag $end
$var reg 1 8 reg_write_flag $end
$var reg 1 9 reg_read_flag $end
$var reg 4 : func [3:0] $end
$var reg 3 ; alu_control_out [2:0] $end
$var reg 16 < reg1_contents [15:0] $end
$var reg 16 = reg2_contents [15:0] $end
$var reg 16 > alu_result [15:0] $end
$var reg 16 ? data_memory_output [15:0] $end
$var reg 16 @ memToReg_mux_output [15:0] $end
$var wire 1 A mem_to_ $end
$scope module pc $end
$var wire 1 B clock $end
$var reg 32 * pc_current [31:0] $end
$var wire 1 C flag_branch $end
$var wire 1 D flag_branch_select $end
$var wire 1 E aluZero $end
$var wire 1 F flag_jump $end
$var wire 16 G fullInstr [15:0] $end
$var reg 32 + pc_next [31:0] $end
$var reg 32 H nextAddr [31:0] $end
$var reg 32 I branchAddr [31:0] $end
$var reg 32 J signExtImm [31:0] $end
$var reg 1 K beq_logic $end
$var reg 1 L bne_logic $end
$var reg 1 M branchMux $end
$var reg 32 N pcSrc [31:0] $end
$var reg 32 O jumpAddr [31:0] $end
$upscope $end
$scope module ra $end
$var reg 16 ! incomingData [15:0] $end
$var reg 32 % index [31:0] $end
$var reg 1 & clock $end
$var reg 1 8 write_flag $end
$var reg 16 # outgoingData [15:0] $end
$upscope $end
$scope module imem $end
$var reg 32 ) addr [31:0] $end
$var reg 16 , outWord [15:0] $end
$var reg 8 P temp1 [7:0] $end
$var reg 8 Q temp2 [7:0] $end
$upscope $end
$scope module dmem $end
$var reg 16 " inWord [15:0] $end
$var reg 1 & clock $end
$var reg 32 ( addr [31:0] $end
$var wire 1 R read_flag $end
$var wire 1 S write_flag $end
$var reg 16 $ outWord [15:0] $end
$scope begin Block38_6 $end
$var reg 32 T wmemtrnsf_fd [31:0] $end
$scope begin Block38_7 $end
$var reg 32 U i1 [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module con $end
$var wire 4 V opcode [3:0] $end
$var wire 1 W control_reset $end
$var reg 1 0 jump $end
$var reg 1 - branch $end
$var reg 1 . branch_select $end
$var reg 1 5 mem_read $end
$var reg 1 X mem_to_reg $end
$var reg 2 4 alu_op [1:0] $end
$var reg 1 6 mem_write $end
$var reg 1 7 aluSrc $end
$var reg 1 8 reg_write $end
$upscope $end
$scope module alu_con $end
$var wire 2 Y alu_op [1:0] $end
$var wire 4 Z func [3:0] $end
$var reg 3 ; alu_control_var [2:0] $end
$var reg 6 [ alu_control_inp [5:0] $end
$upscope $end
$scope module alu $end
$var wire 16 \ input1 [15:0] $end
$var wire 16 ] input2 [15:0] $end
$var wire 16 ^ fullInstr [15:0] $end
$var wire 1 _ flag_aluSrc $end
$var wire 3 ` alu_control_out [2:0] $end
$var reg 16 > result [15:0] $end
$var reg 1 / zero_flag $end
$var reg 16 a adderFirstOperand [15:0] $end
$var reg 16 b signExtImm [15:0] $end
$upscope $end
$upscope $end
$enddefinitions $end

#1000
$dumpvars
b0 !
b0 "
b0 #
b0 $
b11 %
1&
b1 '
b1000000 (
b0 )
b0 *
b10 +
b0 ,
0-
0.
x/
00
b0 1
02
x3
b10 4
05
06
07
18
09
bx :
b0 ;
bx <
bx =
bx >
b0 ?
b0 @
0A
1B
0C
0D
xE
0F
b0 G
b10 H
b10 I
b0 J
0K
0L
0M
b10 N
b0 O
b0 P
b0 Q
0R
0S
b0 T
b0 U
b0 V
0W
0X
b10 Y
bx Z
b10xxxx [
bx \
bx ]
b0 ^
0_
b0 `
bx a
b0 b
$end

#2000
b0 :
b10 ;
b0 Z
b100000 [
b10 `

#3000
b0 %
b0 '
b0 <
b0 \
b0 a

#4000
1/
b0 =
b0 >
bx @
1E
b0 ]

#5000
b10000 %
b1 '

#6000
0&
0B

#7000
bx !
b0 %
1&
1B

#8000
bx #
0&
0B

#9000
b10 !

#10000
b0 '

#11000
b0 *

#14000
x/
bx <
bx >
xE
bx \
bx a

#15000
bx =
bx ]

#16000
b10000 %
b1 '

#18000
bx !
b0 %
1&
1B

#19000
0&
0B

#20000
b10 !

#21000
b0 '

#22000
b0 *

#27000
b10000 %
b1 '

#29000
bx !
b0 %
1&
1B

#30000
0&
0B

#31000
b10 !

#32000
b0 '

#33000
b0 *

#38000
b10000 %
b1 '

#40000
bx !
b0 %
1&
1B

#41000
0&
0B

#42000
b10 !

#43000
b0 '

#44000
b0 *

#49000
b10000 %
b1 '

#51000
bx !
b0 %
1&
1B

#52000
0&
0B

#53000
b10 !

#54000
b0 '

#55000
b0 *

#60000
b10000 %
b1 '

#62000
bx !
b0 %
1&
1B

#63000
0&
0B

#64000
b10 !

#65000
b0 '

#66000
b0 *

#71000
b10000 %
b1 '

#73000
bx !
b0 %
1&
1B

#74000
0&
0B

#75000
b10 !

#76000
b0 '

#77000
b0 *

#82000
b10000 %
b1 '

#84000
bx !
b0 %
1&
1B

#85000
0&
0B

#86000
b10 !

#87000
b0 '

#88000
b0 *

#93000
b10000 %
b1 '

#95000
bx !
b0 %
1&
1B

#96000
0&
0B

#97000
b10 !

#98000
b0 '

#99000
b0 *

#104000
b10000 %
b1 '

#106000
bx !
b0 %
1&
1B

#107000
0&
0B

#108000
b10 !

#109000
b0 '

#110000
b0 *

#115000
b10000 %
b1 '

#117000
bx !
b0 %
1&
1B

#118000
0&
0B

#119000
b10 !
