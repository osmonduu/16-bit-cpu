$date
   Mon Apr 14 14:09:29 2025
$end

$version
  2024.2.0
  $dumpfile ("tb.vcd") 
$end

$timescale
  1ps
$end

$scope module full_tb $end
$var reg 16 ! reg_write [15:0] $end
$var reg 16 " mem_write [15:0] $end
$var reg 16 # reg_result [15:0] $end
$var reg 16 $ mem_result [15:0] $end
$var reg 32 % idx [31:0] $end
$var reg 1 & clock $end
$var reg 32 ' reg_operation_type [31:0] $end
$var reg 32 ( daddr [31:0] $end
$var reg 32 ) iaddr [31:0] $end
$var reg 32 * current_address [31:0] $end
$var reg 32 + next_address [31:0] $end
$var reg 16 , fetched_instruction [15:0] $end
$var reg 16 - instruction [15:0] $end
$var reg 1 . branch_flag $end
$var reg 1 / branch_select_flag $end
$var reg 1 0 alu_zero_flag $end
$var reg 1 1 jump_flag $end
$var reg 4 2 opcode [3:0] $end
$var reg 1 3 control_reset $end
$var reg 1 4 mem_to_reg_flag $end
$var reg 2 5 alu_op [1:0] $end
$var reg 1 6 mem_read_flag $end
$var reg 1 7 mem_write_flag $end
$var reg 1 8 aluSrc_flag $end
$var reg 1 9 reg_write_flag $end
$var reg 1 : reg_read_flag $end
$var reg 4 ; func [3:0] $end
$var reg 3 < alu_control_out [2:0] $end
$var reg 16 = reg1_contents [15:0] $end
$var reg 16 > reg2_contents [15:0] $end
$var reg 16 ? alu_result [15:0] $end
$var reg 16 @ data_memory_output [15:0] $end
$var reg 16 A memToReg_mux_output [15:0] $end
$var wire 1 B mem_to_ $end
$scope module pc $end
$var wire 1 C clock $end
$var reg 32 * pc_current [31:0] $end
$var wire 1 D flag_branch $end
$var wire 1 E flag_branch_select $end
$var wire 1 F aluZero $end
$var wire 1 G flag_jump $end
$var wire 16 H fullInstr [15:0] $end
$var reg 32 + pc_next [31:0] $end
$var reg 32 I nextAddr [31:0] $end
$var reg 32 J branchAddr [31:0] $end
$var reg 32 K signExtImm [31:0] $end
$var reg 1 L beq_logic $end
$var reg 1 M bne_logic $end
$var reg 1 N branchMux $end
$var reg 32 O pcSrc [31:0] $end
$var reg 32 P jumpAddr [31:0] $end
$upscope $end
$scope module ra $end
$var reg 16 ! incomingData [15:0] $end
$var reg 32 % index [31:0] $end
$var reg 1 & clock $end
$var reg 1 9 write_flag $end
$var reg 16 # outgoingData [15:0] $end
$upscope $end
$scope module imem $end
$var reg 32 ) addr [31:0] $end
$var reg 16 , outWord [15:0] $end
$var reg 8 Q temp1 [7:0] $end
$var reg 8 R temp2 [7:0] $end
$upscope $end
$scope module dmem $end
$var reg 16 " inWord [15:0] $end
$var reg 1 & clock $end
$var reg 32 ( addr [31:0] $end
$var wire 1 S read_flag $end
$var wire 1 T write_flag $end
$var reg 16 $ outWord [15:0] $end
$scope begin Block38_6 $end
$var reg 32 U wmemtrnsf_fd [31:0] $end
$scope begin Block38_7 $end
$var reg 32 V i1 [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module con $end
$var wire 4 W opcode [3:0] $end
$var wire 1 X control_reset $end
$var reg 1 1 jump $end
$var reg 1 . branch $end
$var reg 1 / branch_select $end
$var reg 1 6 mem_read $end
$var reg 1 Y mem_to_reg $end
$var reg 2 5 alu_op [1:0] $end
$var reg 1 7 mem_write $end
$var reg 1 8 aluSrc $end
$var reg 1 9 reg_write $end
$upscope $end
$scope module alu_con $end
$var wire 2 Z alu_op [1:0] $end
$var wire 4 [ func [3:0] $end
$var reg 3 < alu_control_var [2:0] $end
$var reg 6 \ alu_control_inp [5:0] $end
$upscope $end
$scope module alu $end
$var wire 16 ] input1 [15:0] $end
$var wire 16 ^ input2 [15:0] $end
$var wire 16 _ fullInstr [15:0] $end
$var wire 1 ` flag_aluSrc $end
$var wire 3 a alu_control_out [2:0] $end
$var reg 16 ? result [15:0] $end
$var reg 1 0 zero_flag $end
$var reg 16 b adderFirstOperand [15:0] $end
$var reg 16 c signExtImm [15:0] $end
$upscope $end
$upscope $end
$enddefinitions $end

#1000
$dumpvars
b0 !
b0 "
b0 #
b0 $
b11 %
0&
b1 '
b1000000 (
b0 )
b0 *
b0 +
b100100000 ,
b0 -
0.
0/
x0
01
bx 2
03
x4
b0 5
06
07
08
09
0:
bx ;
b10 <
bx =
bx >
bx ?
b0 @
b0 A
0B
0C
0D
0E
xF
0G
b0 H
b0 I
b0 J
b0 K
xL
xM
xN
b0 O
b0 P
b1 Q
b100000 R
0S
0T
b0 U
b0 V
bx W
0X
0Y
b0 Z
bx [
b0xxxx \
bx ]
bx ^
b0 _
0`
b10 a
bx b
b0 c
$end
