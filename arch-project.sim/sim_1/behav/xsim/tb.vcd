$date
   Thu Apr 10 19:35:30 2025
$end

$version
  2024.2.2
  $dumpfile ("tb.vcd") 
$end

$timescale
  1ps
$end

$scope module tb $end
$var reg 16 ! reg_in1 [15:0] $end
$var reg 16 " reg_in2 [15:0] $end
$var reg 16 # mem_in [15:0] $end
$var reg 16 $ reg_result [15:0] $end
$var reg 16 % mem_result [15:0] $end
$var reg 16 & alu_result [15:0] $end
$var reg 16 ' ctl_result [15:0] $end
$var reg 16 ( pcc_result [15:0] $end
$var reg 32 ) testcase [31:0] $end
$var reg 32 * idx [31:0] $end
$var reg 1 + clock $end
$var reg 32 , optype [31:0] $end
$var reg 32 - addr [31:0] $end
$var reg 32 . current_address [31:0] $end
$var reg 32 / next_addr [31:0] $end
$var reg 16 0 dummy_instruction [15:0] $end
$var reg 1 1 branch_flag $end
$var reg 1 2 branch_type $end
$var reg 1 3 jump_flag $end
$var reg 1 4 zero_flag $end
$var reg 4 5 opcode [3:0] $end
$var reg 1 6 reset $end
$var reg 1 7 RegDst $end
$var reg 1 8 Jump $end
$var reg 1 9 Branch $end
$var reg 1 : MemRead $end
$var reg 1 ; MemtoReg $end
$var reg 1 < MemWrite $end
$var reg 1 = ALUSrc $end
$var reg 1 > RegWrite $end
$var wire 2 ? ALUOp [1:0] $end
$upscope $end
$scope module glbl $end
$upscope $end
$enddefinitions $end

#0
$dumpvars
b1011111011101111 !
b0 "
b0 #
bx $
bx %
bx &
bx '
bx (
b11 )
b10000 *
0+
b0 ,
b0 -
b0 .
b0 /
b0 0
01
02
03
04
bx 5
16
x7
x8
x9
x:
x;
x<
x=
x>
bx ?
0@
0A
0B
0C
0D
b0 E
b0 F
b0 G
b0 H
xI
xJ
xK
b0 L
b0 M
0N
$end

#1000
b0 $
b1000000100000 %
1+
b10 /
1@
b10 F
b10 G
0I
0J
0K
b10 L
1N

#2000
b10 !
0+
b1000000100000 0
0@
b1000000100000 E
0N

#3000
1+
1@
b1000000 M
1N

#4000
0+
0@
0N

#5000
1+
1@
1N

#6000
0+
0@
0N

#7000
1+
1@
1N

#8000
0+
